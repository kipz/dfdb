(ns dfdb.dd.full-pipeline
  "Complete DD pipeline for ALL Datalog query types - NO fallback."
  (:require [dfdb.dd.delta-core :as delta]
            [dfdb.dd.incremental-core :as core]
            [dfdb.dd.multipattern :as mp]
            [dfdb.dd.aggregate :as agg]
            [dfdb.dd.multiset :as ms]
            [dfdb.dd.operator :as op]
            [dfdb.dd.recursive-incremental :as rec]
            [dfdb.query :as query]
            [dfdb.index :as index]))

(set! *warn-on-reflection* true)

(declare add-not-filter)

(defn pattern-clause? [clause]
  (and (vector? clause)
       (not (list? (first clause)))
       (not (and (seq? clause) (= 'not (first clause))))))

(defn predicate-clause? [clause]
  (or (and (vector? clause) (list? (first clause)))
      (list? clause)))

(defn not-clause? [clause]
  (and (seq? clause) (= 'not (first clause))))

(defn recursive-pattern? [pattern]
  (and (pattern-clause? pattern)
       (keyword? (second pattern))
       (.endsWith (name (second pattern)) "+")))

;; =============================================================================
;; Predicate Support
;; =============================================================================

(defn predicate-to-fn [pred-clause]
  (let [pred-list (if (vector? pred-clause) (first pred-clause) pred-clause)
        [op & args] pred-list]
    (fn [binding]
      (let [resolved (map #(if (and (symbol? %) (.startsWith ^String (name %) "?"))
                             (get binding %)
                             %)
                          args)
            comparable (map #(if (instance? java.util.Date %)
                               (.getTime ^java.util.Date %)
                               %)
                            resolved)]
        (apply (case op
                 > >
                 < <
                 >= >=
                 <= <=
                 = =
                 not= not=)
               comparable)))))

;; =============================================================================
;; Pipeline with Predicates
;; =============================================================================

(defn make-predicate-filters
  "Create predicate filter operators from predicate clauses."
  [predicates]
  (map #(core/->PredicateFilter (predicate-to-fn %)) predicates))

;; =============================================================================
;; Complete Builder
;; =============================================================================

(defn build-pipeline
  "Build complete DD pipeline. Throws on unsupported."
  ([query-form] (build-pipeline query-form nil))
  ([query-form db]

   (let [{:keys [find where aggregates group-vars]} (query/parse-query query-form)

         pure-patterns (filter pattern-clause? where)
         recursive-patterns (filter recursive-pattern? where)
         predicates (filter predicate-clause? where)
         not-clauses (filter not-clause? where)]

     (cond
       ;; Recursive patterns
       (seq recursive-patterns)
       (when db
         ;; For now: handle simple case with recursive pattern
         (rec/make-recursive-pipeline db where find))

       ;; Aggregates
       (seq aggregates)
       (let [;; Get all variables used in ALL aggregate expressions
             agg-vars (distinct (map second aggregates))
             all-vars (vec (concat group-vars agg-vars))

            ;; Create predicate filters to apply during incremental updates
             pred-filters (make-predicate-filters predicates)

            ;; Build base WITH predicate filters (keep full bindings)
            ;; We pass all-vars so the base knows what to keep
             base (mp/make-multi-pattern-pipeline pure-patterns all-vars pred-filters)

             _ (when-not base
                 (throw (ex-info "Could not build pattern pipeline"
                                 {:query query-form})))

            ;; For aggregates, we work directly on result tuples:
            ;; The base pipeline returns tuples like [group-key... var1 var2 ...]
            ;; where positions match all-vars order

            ;; Extract grouping key from tuple
             group-fn (if (seq group-vars)
                       ;; First N elements are group vars
                        (fn [tuple]
                          (vec (take (count group-vars) tuple)))
                        (constantly :all))

            ;; Create aggregate operators for each aggregate expression
            ;; Each operates on the same grouping but different variables/aggregations
             agg-ops (vec
                      (for [[agg-fn agg-var] aggregates]
                        (let [;; Find position of this var in all-vars
                              var-idx (.indexOf ^java.util.List all-vars agg-var)
                              ;; Extract value for this specific variable
                              value-fn (fn [tuple] (nth tuple var-idx))
                              ;; Wrap agg-fn to extract values from tuples
                              tuple-agg-fn (case agg-fn
                                             count agg/agg-count
                                             sum (comp agg/agg-sum (partial map value-fn))
                                             avg (comp agg/agg-avg (partial map value-fn))
                                             min (comp agg/agg-min (partial map value-fn))
                                             max (comp agg/agg-max (partial map value-fn)))]
                          (agg/make-aggregate-operator group-fn tuple-agg-fn nil))))

             collect-agg (core/->CollectResults {:accumulated (atom {})})

            ;; Use a fixed timestamp for this aggregate pipeline (we don't need temporal versions)
             current-timestamp (atom 0)

         ;; Helper to extract current aggregate results from operators
             extract-agg-results (fn []
                                   (let [ts @current-timestamp
                                         first-agg-state @(:aggregates (:state (first agg-ops)))
                                         all-timestamps (keys first-agg-state)
                                         _ (when (> (count all-timestamps) 1)
                                             (println "WARNING: Multiple timestamps in aggregate state:" all-timestamps))
                                         first-aggregates (get first-agg-state ts)]
                                     (when first-aggregates
                                       (set
                                        (for [group-key (keys first-aggregates)]
                                          (let [agg-values (vec
                                                            (for [agg-op agg-ops]
                                                              (let [state @(:aggregates (:state agg-op))
                                                                    aggs (get state ts)]
                                                                (get aggs group-key))))]
                                            (if (= :all group-key)
                                              agg-values
                                              (vec (concat group-key agg-values)))))))))]

         {:process-deltas
          (fn [tx-deltas]
           ;; Get current aggregate results BEFORE processing
            (let [old-results (or (extract-agg-results) #{})]

             ;; Process through base
              ((:process-deltas base) tx-deltas)

             ;; Get intermediate results (tuples) with multiplicities preserved
              (let [;; For aggregates, we need to preserve multiplicities from base CollectResults
                    ;; Don't use get-results which collapses multiplicities via set conversion
                    base-accumulated (when-let [base-ops (:operators base)]
                                       (when-let [collect (:collect base-ops)]
                                         @(:accumulated (:state collect))))
                    ;; Use accumulated map directly as multiset
                    ms (if base-accumulated
                         (ms/multiset base-accumulated)
                         ;; Fallback to get-results for non-join cases
                         (let [intermediate ((:get-results base))]
                           (ms/multiset (into {} (map (fn [v] [v 1]) intermediate)))))]

               ;; Feed to ALL aggregate operators with consistent timestamp
                (let [ts @current-timestamp]
                  (doseq [agg-op agg-ops]
                    (op/input agg-op ms ts)))

               ;; Get new aggregate results AFTER processing
                (let [new-results (or (extract-agg-results) #{})

                      ;; Compute differential
                      additions (clojure.set/difference new-results old-results)
                      retractions (clojure.set/difference old-results new-results)

                      ;; Debug if there are changes but no retractions (unexpected for aggregates)
                      _ (when (and (seq additions) (empty? retractions) (seq old-results))
                          (println "WARNING: Additions without retractions!")
                          (println "  old-results:" old-results)
                          (println "  new-results:" new-results)
                          (println "  additions:" additions))]

                 ;; Feed differential to collect operator
                  ;; Debug: check if retractions exist in collect-agg
                  (when (seq retractions)
                    (let [collect-state @(:accumulated (:state collect-agg))
                          missing-in-collect (filter (fn [r] (not (pos? (get collect-state r 0)))) retractions)]
                      (when (seq missing-in-collect)
                        (println "WARNING: Retracting values not in collect-agg:" missing-in-collect)
                        (println "  Current collect-agg positive entries:"
                                 (filter (fn [[k v]] (pos? v)) collect-state)))))

                  (doseq [result retractions]
                    (let [d (delta/make-delta result -1)]
                      (core/process-delta collect-agg d)))

                  (doseq [result additions]
                    (let [d (delta/make-delta result 1)]
                      (core/process-delta collect-agg d)))))))

          :get-results
          (fn [] (core/get-results collect-agg))

          :base base
          :all-vars all-vars
          :agg-ops agg-ops
          :group-vars group-vars
          :extract-agg-results extract-agg-results
          :operators {:collect collect-agg}})

      ;; Pure patterns with optional predicates and/or NOT clauses
       (seq pure-patterns)
       (let [;; Create predicate filter operators
             pred-filters (make-predicate-filters predicates)
            ;; Build base pipeline with predicates integrated
             base-pipeline (mp/make-multi-pattern-pipeline pure-patterns find pred-filters)]
         (if-not base-pipeline
           (throw (ex-info "Could not build pattern pipeline"
                           {:query query-form}))
           ;; Wrap with NOT filters if needed
           (if (seq not-clauses)
             (reduce (fn [pipeline not-clause]
                       (add-not-filter pipeline not-clause))
                     base-pipeline
                     not-clauses)
             base-pipeline)))

      ;; No patterns
       :else
       (throw (ex-info "Query has no patterns" {:query query-form}))))))

;; =============================================================================
;; NOT Clause Support
;; =============================================================================

(defn add-not-filter
  "Add NOT clause filtering to pipeline."
  [base-pipeline not-clause]

  (let [not-pattern (second not-clause)
        base-process (:process-deltas base-pipeline)
        base-get (:get-results base-pipeline)

        ;; Build pipeline for NOT pattern to track what matches
        not-pipeline (mp/make-multi-pattern-pipeline [not-pattern] [])

        filtered-collect (core/->CollectResults {:accumulated (atom {})})]

    (if not-pipeline
      {:process-deltas
       (fn [tx-deltas]
         ;; Process base pipeline
         (base-process tx-deltas)

         ;; Process NOT pattern to see what matches
         ((:process-deltas not-pipeline) tx-deltas)

         ;; Get results
         (let [base-results (base-get)
               not-results ((:get-results not-pipeline))]

           ;; Clear filtered
           (reset! (:accumulated (:state filtered-collect)) {})

           ;; Emit results that DON'T appear in NOT results
           (doseq [result base-results]
             (when-not (contains? not-results result)
               (core/process-delta filtered-collect (delta/make-delta result 1))))))

       :get-results
       (fn [] (core/get-results filtered-collect))}

      ;; Can't compile NOT pattern
      (throw (ex-info "Could not compile NOT pattern to DD"
                      {:not-pattern not-pattern})))))

;; build-pipeline is the main entry point defined earlier in the file

;; =============================================================================
;; DD Pipeline State Initialization
;; =============================================================================

(defn initialize-pipeline-state
  "Initialize DD pipeline state with existing database contents.
  Uses naive query execution to compute initial results, then directly
  populates the pipeline's final operator state. This avoids the expensive
  process of scanning the entire database and feeding it through the delta pipeline."
  [dd-graph db query-form]
  (when dd-graph
    ;; Run the query naively to get current results
    (let [initial-results (query/query db query-form)
          operators (:operators dd-graph)
          parsed (query/parse-query query-form)
          where-clauses (:where parsed)
          patterns (filter pattern-clause? where-clauses)
          predicates (filter predicate-clause? where-clauses)
          has-aggregates? (seq (:aggregates parsed))]

      ;; Populate join operator states for multi-pattern queries
      ;; This ensures incremental updates can join against existing state
      ;; Skip for aggregate queries - they handle their own base pipeline initialization
      (when (and (> (count patterns) 1) operators (not has-aggregates?))
        (try
          (cond
            ;; 2-pattern join: populate pattern operators and join operator
            (= (count patterns) 2)
            (let [pattern1 (first patterns)
                  pattern2 (second patterns)
                  pattern1-vars (vec (filter #(and (symbol? %) (.startsWith ^String (name %) "?")) pattern1))
                  pattern2-vars (vec (filter #(and (symbol? %) (.startsWith ^String (name %) "?")) pattern2))]

              ;; Only populate if we have variables and a join operator
              (when (and (seq pattern1-vars) (seq pattern2-vars) (:join operators))
                ;; Query each pattern separately to get all current matches
                (let [pattern1-query (vec (concat [:find] pattern1-vars [:where pattern1]))
                      pattern2-query (vec (concat [:find] pattern2-vars [:where pattern2]))
                      pattern1-bindings (try (set (query/query db pattern1-query)) (catch Exception _e #{}))
                      pattern2-bindings (try (set (query/query db pattern2-query)) (catch Exception _e #{}))]

                  ;; Convert result tuples back to binding maps
                  (when (and (seq pattern1-bindings) (seq pattern2-bindings))
                    (let [pattern1-maps (set (map (fn [tuple]
                                                    (if (vector? tuple)
                                                      (zipmap pattern1-vars tuple)
                                                      {(first pattern1-vars) tuple}))
                                                  pattern1-bindings))
                          pattern2-maps (set (map (fn [tuple]
                                                    (if (vector? tuple)
                                                      (zipmap pattern2-vars tuple)
                                                      {(first pattern2-vars) tuple}))
                                                  pattern2-bindings))
                          join-op (:join operators)
                          left-state (:left-state join-op)
                          right-state (:right-state join-op)]
                      (reset! left-state (into {} (map (fn [binding] [binding 1]) pattern1-maps)))
                      (reset! right-state (into {} (map (fn [binding] [binding 1]) pattern2-maps))))))))

            ;; 3+ pattern join: initialize pattern operators and join operators
            (> (count patterns) 2)
            (let [pattern-ops (:patterns operators)
                  join-ops (:joins operators)]
              (when (and pattern-ops join-ops)
                ;; Query each pattern to get current bindings
                (let [pattern-bindings
                      (vec
                       (for [pattern patterns]
                         (let [pattern-vars (vec (filter #(and (symbol? %)
                                                               (.startsWith ^String (name %) "?"))
                                                         pattern))
                               pattern-query (vec (concat [:find] pattern-vars [:where pattern]))
                               bindings (try (set (query/query db pattern-query))
                                             (catch Exception _e #{}))]
                           (set (map (fn [tuple]
                                       (if (vector? tuple)
                                         (zipmap pattern-vars tuple)
                                         {(first pattern-vars) tuple}))
                                     bindings)))))]

                  ;; Initialize pattern operator states
                  (doseq [[pattern-op bindings] (map vector pattern-ops pattern-bindings)]
                    (when-let [state (:state pattern-op)]
                      (reset! state (into {} (map (fn [binding] [binding 1]) bindings)))))

                  ;; Initialize join operator states
                  ;; We need to progressively compute actual join results for correctness
                  (loop [join-idx 0
                         accumulated-result (nth pattern-bindings 0)]
                    (when (< join-idx (count join-ops))
                      (let [join-op (nth join-ops join-idx)
                            right-pattern-idx (inc join-idx)
                            right-bindings (nth pattern-bindings right-pattern-idx)

                            ;; Compute join variables
                            left-vars (set (mapcat keys accumulated-result))
                            right-vars (set (mapcat keys right-bindings))
                            join-vars (vec (filter left-vars right-vars))

                            ;; Compute actual join result
                            join-result (set
                                         (for [left accumulated-result
                                               right right-bindings
                                               :let [left-jk (select-keys left join-vars)
                                                     right-jk (select-keys right join-vars)]
                                               :when (= left-jk right-jk)]
                                           (merge left right)))]

                        ;; Initialize join operator state
                        (reset! (:left-state join-op)
                                (into {} (map (fn [b] [b 1]) accumulated-result)))
                        (reset! (:right-state join-op)
                                (into {} (map (fn [b] [b 1]) right-bindings)))

                        ;; Continue with join result for next iteration
                        (recur (inc join-idx) join-result)))))))

            :else nil)
          (catch Exception e
            ;; If join initialization fails, log and continue with just CollectResults
            (println "Warning: Failed to initialize join operator state:" (.getMessage ^Exception e)))))

      ;; For aggregate queries, initialize the base pipeline's CollectResults
      ;; with raw tuples (before aggregation) AND feed them through aggregate operators
      (when has-aggregates?
        (when-let [base (:base dd-graph)]
          (when-let [all-vars (:all-vars dd-graph)]
            (when-let [base-ops (:operators base)]
              (when-let [base-collect (:collect base-ops)]
                (try
                  ;; Initialize join operators in the base pipeline if this is a multi-pattern aggregate
                  (when (> (count patterns) 1)
                    (let [pattern-ops (:patterns base-ops)
                          join-ops (:joins base-ops)]
                      (when (and pattern-ops join-ops)
                        (let [pattern-bindings
                              (vec
                               (for [pattern patterns]
                                 (let [pattern-vars (vec (filter #(and (symbol? %)
                                                                       (.startsWith ^String (name %) "?"))
                                                                 pattern))
                                       pattern-query (vec (concat [:find] pattern-vars [:where pattern]))
                                       bindings (try (set (query/query db pattern-query))
                                                     (catch Exception _e #{}))]
                                   (set (map (fn [tuple]
                                               (if (vector? tuple)
                                                 (zipmap pattern-vars tuple)
                                                 {(first pattern-vars) tuple}))
                                             bindings)))))]
                          (doseq [[pattern-op bindings] (map vector pattern-ops pattern-bindings)]
                            (when-let [state (:state pattern-op)]
                              (reset! state (into {} (map (fn [binding] [binding 1]) bindings)))))
                          ;; Initialize join operators with actual join results
                          (loop [join-idx 0
                                 accumulated-result (nth pattern-bindings 0)]
                            (when (< join-idx (count join-ops))
                              (let [join-op (nth join-ops join-idx)
                                    right-pattern-idx (inc join-idx)
                                    right-bindings (nth pattern-bindings right-pattern-idx)
                                    left-vars (set (mapcat keys accumulated-result))
                                    right-vars (set (mapcat keys right-bindings))
                                    join-vars (vec (filter left-vars right-vars))
                                    join-result (set
                                    (for [left accumulated-result
                                          right right-bindings
                                          :let [left-jk (select-keys left join-vars)
                                                right-jk (select-keys right join-vars)]
                                          :when (= left-jk right-jk)]
                                      (merge left right))]
                                (reset! (:left-state join-op)
                                        (into {} (map (fn [b] [b 1]) accumulated-result)))
                                (reset! (:right-state join-op)
                                        (into {} (map (fn [b] [b 1]) right-bindings)))
                                (recur (inc join-idx) join-result))))))))

                  ;; Query the patterns without aggregation to get raw tuples
                  ;; CRITICAL: Query with ALL pattern vars to prevent deduplication!
                  (let [all-pattern-vars (get dd-graph :all-pattern-vars)
                        result-vars (get dd-graph :result-vars)
                        base-where (vec (concat patterns predicates))
                        base-query-all (vec (concat [:find] all-pattern-vars [:where] base-where))
                        raw-tuples-all-vars (query/query db base-query-all)
                        ;; Project to result-vars and count duplicates
                        var-to-idx (into {} (map-indexed (fn [idx v] [v idx]) all-pattern-vars))
                        result-indices (mapv var-to-idx result-vars)
                        raw-tuples (map (fn [tuple]
                                          (mapv #(nth tuple %) result-indices))
                                        raw-tuples-all-vars)
                        base-accumulated-atom (:accumulated (:state base-collect))
                        raw-tuples-map (frequencies raw-tuples)]
                    (reset! base-accumulated-atom raw-tuples-map)

                    ;; Feed raw tuples through aggregate operators to initialize them
                    (when-let [agg-ops (get-in dd-graph [:agg-ops])]
                      (let [ms (ms/multiset raw-tuples-map)]
                        (doseq [agg-op agg-ops]
                          (op/input agg-op ms 0)))))

                    ;; Aggregate operators now initialized
                  (catch Exception e
                    (println "Warning: Failed to initialize base pipeline for aggregates:" (.getMessage ^Exception e)))))))))

      ;; Populate the final CollectResults operator with initial results
      ;; Each result gets multiplicity 1 (present in current state)
      ;; EXCEPT for aggregate queries which handle this specially above
      (when-not has-aggregates?
        (when-let [collect-op (:collect operators)]
          (let [accumulated (:accumulated (:state collect-op))]
            (reset! accumulated
                    (into {} (map (fn [result] [result 1]) initial-results)))))))))
